#!/usr/bin/python
# -*- coding: utf-8 -*-
# @Time    : 2020/12/3 19:40
# @Author  : Dodo
# @File    : GaussConv.py
# @Software: PyCharm
# @Contact : gr_yao@126.com
# @Function: Build a 5x5 Gauss kernel and make Gauss convolution.
import cv2
import numpy as np
import matplotlib.pyplot as plt


def generate_kernel(sigma, ker_size=3):
    """
    This function is used to generate the Gaussian kernel required for Gaussian convolution.

    :param sigma: The sigma parameter in Gaussian distribution.
    :param ker_size: The size of the Gaussian kernel.
    :return: Generated Gaussian kernel.
    """
    # Initialize the kernel.
    ker = np.zeros([ker_size, ker_size])
    # Find the center of the kernel.
    center = ker_size // 2

    # Exclude the case that sigma is not a positive number.
    if sigma <= 0:
        raise Exception("'sigma' must be a positive number!")

    # Calculate the values in the kernel.
    for i in range(0, ker_size):
        for j in range(0, ker_size):
            x = i - center
            y = j - center
            ker[i, j] = np.exp(- (x ** 2 + y ** 2) / 2 * (sigma ** 2))

    # Return the generated kernel.
    return ker / np.sum(np.sum(ker, axis=0), axis=0)


def gauss_conv_2d(ker, img):
    """
    This function uses the given Gaussian kernel to perform Gaussian convolution.

    :param ker: The given Gaussian kernel.
    :param img: Image that requires Gaussian convolution.
    :return: The image generated by Gaussian convolution.
    """
    # Fill the edge of the image to ensure that
    # the output image is the same size as the original.
    pad_h = ker.shape[0] // 2
    pad_w = ker.shape[1] // 2
    img = np.pad(img, (pad_h, pad_w), 'reflect')

    # The width and height of the output image.
    h = img.shape[0] - ker.shape[0] + 1
    w = img.shape[1] - ker.shape[1] + 1

    # Initialize the result image.
    res = np.zeros((h, w))

    # Convolution operation.
    ker_h = ker.shape[0]
    ker_w = ker.shape[1]
    for i in range(h):
        for j in range(w):
            res[i, j] = np.sum(img[i: i + ker_h, j: j + ker_w] * ker)

    # Return the result image.
    return res


if __name__ == "__main__":
    kernel = generate_kernel(0.5, ker_size=5)
    image = cv2.imread("test.jpg", cv2.IMREAD_GRAYSCALE)
    image = cv2.resize(image, (image.shape[1] // 10, image.shape[0] // 10))
    result = gauss_conv_2d(kernel, image)
    plt.imshow(result)
    plt.show()
